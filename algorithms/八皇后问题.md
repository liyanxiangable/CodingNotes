# 八皇后问题

> 八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出结果。计算机发明后，有多种计算机语言可以解决此问题。

无意间看到这个问题，一直在打农药，晚上了做点正事吧，我来试着解一下。

首先每个皇后都是等效的，所以第一个皇后棋子放在 A 位置并且第二个皇后棋子放在 B 位置，与第一个皇后棋子放在 B 位置并且第二个皇后棋子放在 A 位置是一样的，这应当算作一种情况。

我首先想到的暴力的遍历，这样的话最多要进行 8 ^ 2 ^8 次判断，这显然不是一种好的方法。当然这种方法还可以优化，并不需要真的遍历这么多次，但是算法的复杂度依然很高。

其中的一个弊端就在于我一开始是想一共有 8 个棋子，每个棋子可以放的位置为 8 ^ 2 = 64 个。但是实际上由于每个皇后棋子都不能在同一条线上，并且刚才提到每个皇后棋子都是等效的，所以问题就可以简化为先在第一行放置第一个皇后棋子，再到第二行放置第二个皇后棋子……以此类推，所以并不需要在整个棋盘上选定棋子的放置位置，所以问题空间简化为 8 ^ 8 或者是不考虑在一条线上的情况，此时为 8! = 40320 种情况。

可以使用循环来做，但是循环写起来要八次嵌套，而且如果是很大的横竖为 n 行的棋盘，也要写 n 个循环吗？所以我使用递归来做，递归 8 次，最终得到结果。

递归的思路是怎样的？首先在每一行上任取（循环遍历）一个位置，然后判断这个位置是否有效。如果无效，那么就 return 到上一层继续遍历下一个位置；如果位置有效，那么就继续到下一行寻找合适的位置。直到第八行（第八次递归），这个时候如果位置任然有效，就说明 8 个皇后棋子都是有效的，算作一种解。最后还需要将棋子在当前位置上拿走。

那么怎么判断皇后棋子的摆放位置是否有效呢？假设现在摆放第 n 行的棋子 Q，它的位置为 Q(x, y)，在他之前有棋子（如果 n = 0，则不存在之前的棋子，那么 Q 的位置总是有效）的位置 P(m, n)，那么两个棋子不冲突的条件是不能在同一行、不能在同一列并且不能在同一对角线上。翻译成数学语言就是：

```
x != m
y != n
x - m != y - n
x - m != n - y
```

所以判断一个棋子的位置是否合法，要对现有的 n 个棋子两两之间进行以上的判断。但是由于简化了棋子的纵坐标，现在的棋子只有一个横坐标（反过来或也可以），如果我们把棋子位置放到一个数组之中，想要获得省略的那一个坐标，其实就是棋子数组的索引位置。即在第 n 次递归的时候，是放置第 n 个棋子到第 n 行的过程，他之前的棋子的位置依次为：(0, a)，(1, b)，(2, c)……(n, x)。这些棋子之间需要符合以上的关系，我一开始使这么写的：

```java
private boolean isValidPosition(int[] positions, int row) {
  if (row == 0) {
    // 第一行的时候，位置总是合法的
    return true;
  } else {
    for (int i = 0; i <= row; i++) {
      for (int j = i; j <= row; j++) {
        // 通过两个循环，使当前所有棋子位置两两进行条件判断
		return ...;
      }
    }
  }
}
```

但是想了一下，其中的两个循环多此一举了。因为虽然理论上使需要两两满足条件，但是如果一旦有不满足条件的情况，那一行的棋子就会换到下一个位置，因此对于第 n 行来说，不需要考虑 n - 1 行之前的位置是否合法（递归保证），只需要考虑当前行的位置是否能与其他行位置不起冲突即可。所以代码如下：

```java
private boolean isValidPosition(int[] positions, int row) {
  System.out.println(Arrays.toString(positions));
  if (row == 0) {
    // 第一行的时候，位置总是合法的
    return true;
  } else {
    for (int i = 0; i < row; i++) {
      // 由于已经考虑不同行的顺序放置棋子，所以不需要比较纵坐标（即positions[]的索引）
      // 1. 首先判断横坐标是否相等
      if (positions[i] == positions[row]) {
        System.out.println("位置 (" + i + ", " + positions[i] + ") 与位置 (" + row + ", " + positions[row] + ") 在同一列，因此不合法");
        return false;
      }
      // 2. 判断是否与之前的棋子在同一对角线上
      if (row - i == positions[row] - positions[i] || row - i == positions[i] - positions[row]) {
        System.out.println("位置 (" + row + ", " + positions[row] + ") 与位置 (" + i + ", " + positions[i] + ") 在对角线上，因此不合法");
        return false;
      }
    }
    return true;
  }
}
```

然后根据以上的分析，对于一个递归的放置棋子的函数来说，他需要的参数为：

1. 当前的行数
2. 截止到当前的所有棋子的位置

所以放置棋子的函数如下：

```java
private void put(int row, int[] positions) {
  System.out.println("当前是对第 " + row + " 行进行放置");
  for (int i = 0; i < ROW; i++) {
    // 设定第 row 行（row 从 0 开始）的棋子位置
    positions[row] = i;
    System.out.println("将第 " + row + " 行的棋子放在第 " + i + " 位置上");
    // 判断当前放置的位置是否合法
    if (isValidPosition(positions, row)) {
      System.out.println("当前位置 " + i + " 合法");
      // 如果位置合法，判断是否是第 7 行（最后一行），如果是，则为一种符合的放置
      if (row == 7) {
        count++;
        System.out.println(Arrays.toString(positions));
        return;
      }
      // 如果位置合法，但是还没有排到第 7 行，那么应当继续下一行放置棋子
      else {
        System.out.println("未达到最后一行，继续递归");
        put(row + 1, positions);
      }
    } else {
      // 如果位置不合法，那么需要在当前行将位置换为下一个
      System.out.println("当前位置 " + i + " 不合法");
      continue;
    }
  }
}
```

现在来看递归函数大体上就写出来了，最后进行初始化与调用：

```java
public void solution() {
  int[] positions = new int[8];
  put(0, positions);
  System.out.println("共计 " + count + " 种位置。");
}
public static void main(String[] args) {
  EightQueens eightQueens = new EightQueens();
  eightQueens.solution();
}
```

以上就是我对八皇后问题的一点思考。最后整理下全部的核心代码：

```java
import java.util.Arrays;

public class EightQueens {
  final int ROW = 8;
  int count = 0;

  public void solution() {
    int[] positions = new int[8];
    put(0, positions);
    System.out.println(count);
  }

  private void put(int row, int[] positions) {
    for (int i = 0; i < ROW; i++) {
      positions[row] = i;
      if (isValidPosition(positions, row)) {
        if (row == 7) {
          count++;
          System.out.println(Arrays.toString(positions));
          return;
        } else put(row + 1, positions);
      } else continue;
    }
  }

  private boolean isValidPosition(int[] positions, int row) {
    if (row == 0) return true;
    else {
      for (int i = 0; i < row; i++) {
        if (positions[i] == positions[row] ||row - i == positions[row] - positions[i] || row - i == positions[i] - positions[row]) {
          return false;
        }
      }
      return true;
    }
  }

  public static void main(String[] args) {
    EightQueens eightQueens = new EightQueens();
    eightQueens.solution();
  }
}
```

输出的完整结果如下，共计 92 种放置棋子的方式（以下数组元素均为棋子所在的列，索引为所在的行）：

```java
[0, 4, 7, 5, 2, 6, 1, 3]
[0, 5, 7, 2, 6, 3, 1, 4]
[0, 6, 3, 5, 7, 1, 4, 2]
[0, 6, 4, 7, 1, 3, 5, 2]
[1, 3, 5, 7, 2, 0, 6, 4]
[1, 4, 6, 0, 2, 7, 5, 3]
[1, 4, 6, 3, 0, 7, 5, 2]
[1, 5, 0, 6, 3, 7, 2, 4]
[1, 5, 7, 2, 0, 3, 6, 4]
[1, 6, 2, 5, 7, 4, 0, 3]
[1, 6, 4, 7, 0, 3, 5, 2]
[1, 7, 5, 0, 2, 4, 6, 3]
[2, 0, 6, 4, 7, 1, 3, 5]
[2, 4, 1, 7, 0, 6, 3, 5]
[2, 4, 1, 7, 5, 3, 6, 0]
[2, 4, 6, 0, 3, 1, 7, 5]
[2, 4, 7, 3, 0, 6, 1, 5]
[2, 5, 1, 4, 7, 0, 6, 3]
[2, 5, 1, 6, 0, 3, 7, 4]
[2, 5, 1, 6, 4, 0, 7, 3]
[2, 5, 3, 0, 7, 4, 6, 1]
[2, 5, 3, 1, 7, 4, 6, 0]
[2, 5, 7, 0, 3, 6, 4, 1]
[2, 5, 7, 0, 4, 6, 1, 3]
[2, 5, 7, 1, 3, 0, 6, 4]
[2, 6, 1, 7, 4, 0, 3, 5]
[2, 6, 1, 7, 5, 3, 0, 4]
[2, 7, 3, 6, 0, 5, 1, 4]
[3, 0, 4, 7, 1, 6, 2, 5]
[3, 0, 4, 7, 5, 2, 6, 1]
[3, 1, 4, 7, 5, 0, 2, 6]
[3, 1, 6, 2, 5, 7, 0, 4]
[3, 1, 6, 2, 5, 7, 4, 0]
[3, 1, 6, 4, 0, 7, 5, 2]
[3, 1, 7, 4, 6, 0, 2, 5]
[3, 1, 7, 5, 0, 2, 4, 6]
[3, 5, 0, 4, 1, 7, 2, 6]
[3, 5, 7, 1, 6, 0, 2, 4]
[3, 5, 7, 2, 0, 6, 4, 1]
[3, 6, 0, 7, 4, 1, 5, 2]
[3, 6, 2, 7, 1, 4, 0, 5]
[3, 6, 4, 1, 5, 0, 2, 7]
[3, 6, 4, 2, 0, 5, 7, 1]
[3, 7, 0, 2, 5, 1, 6, 4]
[3, 7, 0, 4, 6, 1, 5, 2]
[3, 7, 4, 2, 0, 6, 1, 5]
[4, 0, 3, 5, 7, 1, 6, 2]
[4, 0, 7, 3, 1, 6, 2, 5]
[4, 0, 7, 5, 2, 6, 1, 3]
[4, 1, 3, 5, 7, 2, 0, 6]
[4, 1, 3, 6, 2, 7, 5, 0]
[4, 1, 5, 0, 6, 3, 7, 2]
[4, 1, 7, 0, 3, 6, 2, 5]
[4, 2, 0, 5, 7, 1, 3, 6]
[4, 2, 0, 6, 1, 7, 5, 3]
[4, 2, 7, 3, 6, 0, 5, 1]
[4, 6, 0, 2, 7, 5, 3, 1]
[4, 6, 0, 3, 1, 7, 5, 2]
[4, 6, 1, 3, 7, 0, 2, 5]
[4, 6, 1, 5, 2, 0, 3, 7]
[4, 6, 1, 5, 2, 0, 7, 3]
[4, 6, 3, 0, 2, 7, 5, 1]
[4, 7, 3, 0, 2, 5, 1, 6]
[4, 7, 3, 0, 6, 1, 5, 2]
[5, 0, 4, 1, 7, 2, 6, 3]
[5, 1, 6, 0, 2, 4, 7, 3]
[5, 1, 6, 0, 3, 7, 4, 2]
[5, 2, 0, 6, 4, 7, 1, 3]
[5, 2, 0, 7, 3, 1, 6, 4]
[5, 2, 0, 7, 4, 1, 3, 6]
[5, 2, 4, 6, 0, 3, 1, 7]
[5, 2, 4, 7, 0, 3, 1, 6]
[5, 2, 6, 1, 3, 7, 0, 4]
[5, 2, 6, 1, 7, 4, 0, 3]
[5, 2, 6, 3, 0, 7, 1, 4]
[5, 3, 0, 4, 7, 1, 6, 2]
[5, 3, 1, 7, 4, 6, 0, 2]
[5, 3, 6, 0, 2, 4, 1, 7]
[5, 3, 6, 0, 7, 1, 4, 2]
[5, 7, 1, 3, 0, 6, 4, 2]
[6, 0, 2, 7, 5, 3, 1, 4]
[6, 1, 3, 0, 7, 4, 2, 5]
[6, 1, 5, 2, 0, 3, 7, 4]
[6, 2, 0, 5, 7, 4, 1, 3]
[6, 2, 7, 1, 4, 0, 5, 3]
[6, 3, 1, 4, 7, 0, 2, 5]
[6, 3, 1, 7, 5, 0, 2, 4]
[6, 4, 2, 0, 5, 7, 1, 3]
[7, 1, 3, 0, 6, 4, 2, 5]
[7, 1, 4, 2, 0, 6, 3, 5]
[7, 2, 0, 5, 1, 4, 6, 3]
[7, 3, 0, 2, 5, 1, 6, 4]
92
```





## 参考与感谢

[Eight queens puzzle Wikipedia](https://en.wikipedia.org/wiki/Eight_queens_puzzle) 