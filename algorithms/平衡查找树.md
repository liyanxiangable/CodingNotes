# 平衡查找树



## 2-3 查找树

为了保证查找树的平衡性，我们需要一些灵活性，因此在这里我们允许树中的一个结点保存多个键。确切地说，我们将一棵标准的二叉查找树种的结点称为 2-结点（含有一个键与两条链接），而现在我们引入 3-结点，这样的结点含有两个键和三条链接。2-结点和 3-结点中的每条链接都对应着其中保存的键所分割产生的一个区间。

一棵 2-3 查找树成为一棵空树，或由以下结点组成：

- 2-结点，含有一个键（及其对应的值）和两条链接，左链接指向的 2-3 树中的键都小于该结点，右链接指向的 2-3 树中的键都大于该结点。
- 3-结点，含有两个键（及其对应的值）和三条链接，左链接指向的 2-3 树的键都小于该结点，中链接所指向的 2-3 树的键都位于该结点的两个键之间，右链接指向的 2-3 树中的键都大于该结点。

一棵完美平衡的 2-3 查找树中的所有空链接到根结点的距离都应该是相等的。

## 插入结点操作

### 向 2-结点中插入新键

我们使用 2-3 树的主要原因就是在于它能够在插入后继续保持平衡，如果未命中的查找结束于一个 2-结点，那么我们只要把这个 2-结点替换为一个 3-结点，将要插入的键保存在其中即可。

### 向一棵只含有一个 3-结点的树种插入新键

在考虑一般情况之前，先假设我们需要向一棵只含有一个 3-结点的树种插入一个新键。这棵树中有两个键，所以在它唯一的结点中已经没有可插入新键的空间了。为了将新键插入，我们先临时将键存入该结点中，使之成为一个 4-结点。它很自然地扩展了以前的结点并含有 3 个键与 4 条链接。创建一个 4-结点很方便，因为很容易将它转换为一棵由 3 个 2-结点组成的 2-3 树，其中一个结点（根）含有中键，一个结点含有 3 个键中的最小者（与根结点的左链接相连），一个结点含有 3 个键中的最大者（与根结点的右链接相连）。这棵树即使一棵有 3 个结点的二叉查找树，同时也是一棵完美平衡的 2-3 查找树，因为其中所有的空链接到根结点的距离都相等。

### 向一个父结点为 2-结点的 3-结点中插入新键

假设未命中的查找结束于一个 3-结点，而他的父结点为一个 2-结点。在这种情况下我们需要在维持树的完美平衡的前提下为新键腾出空间。我们先像刚才一样构造一个临时的 4-结点并将其分解，但此时我们不会为中键创建一个新结点，二是将它移动到原来的父结点中。

### 向一个父结点为 3-结点的 3-结点中插入新键

现在假设未命中的查找结束于一个父结点为 3-结点的结点。我们再次和刚才一样构造一个临时的 4-结点并分解它，然后将它的中键插入到它的父结点中。但是父结点也是一个 3-结点，因此我们在用这个中键构造一个新的临时 4- 结点，然后在这个结点上进行相同的变换，即分解这个父结点并将它的中键插入到它的父结点中去。推广到一般情况，我们就这样一直向上不断分解临时的 4-结点并将中键插入更高层的父结点，直到遇到一个 2-结点并将它替换为一个不需要继续分解的 3-结点，或者时到达 3-节点的根。

### 分解根结点

如果从插入结点到根结点的路径上全都是 3-结点，我们的根结点最终变成一个临时的 4-结点。此时我们可以按照向一棵只有一个 3-结点的树种插入新键的方法处理这个问题。我们将临时的 4-结点分解为 3 个 2-结点，使得树高增加 1。这次最后的变换任然保持了树的完美平衡，因为它变换的是根结点。



和标准的二叉查找树由上向下生长不同，2-3树的生长时由下向上的。在一棵大小为 N 的 2-3 树中，查找和插入操作访问的结点必然不超过 logN 个。因此我们可以确定 2-3 树在最坏的情况下仍有较好的性能。

## 红黑二叉查找树

### 替换 3-结点

红黑二叉查找树背后的基本思想是用标准的二叉查找树（完全由 2-结点构成）和一些额外的信息来表示 2-3 树。我们将树中的链接分为两种类型：

1. 红链接，将两个 2-结点连接起来构成一个 3-结点
2. 黑链接，2-3 树中的普通链接

确切地说，我们将 3-结点表示为由一条左斜的红色链接相连的两个 2-结点。我们将用这种方式表示 2-3 树的二叉查找树称为是红黑二叉树。

### 等价的定义

红黑树的另一种定义是含有红黑链接并满足下列条件的二叉查找树：

1. 红链接均为左链接
2. 没有任何一个结点同时和两条红链接相连
3. 该树是完全黑色平衡的，即任意空链接到根结点的路径上的黑链接数量都相同

如果我们将一棵红黑树中的红链接画平，那么所有的空链接到根结点的距离都将是相等的。如果我们将由红链接相连的结点合并，那么得到的就是一棵 2-3 树。

### 结点插入方法

挖坑待填



### 红黑树的性质

所有基于红黑树的符号表实现都能够保证操作的运行时间为对数级别。首先，无论键的插入顺序如何，红黑树都几乎是完美平衡的。一棵大小为 N 的红黑树的高度不会超过 2logN，根结点到任意结点的平均路径长度为 ~1.00logN。

红黑树的 get() 方法不会检查结点的颜色，因此平衡性相关的操作不会产生任何的负担；因为树是平衡的，所以查找比二叉查找树更快。

红黑树最吸引人的一点是它的实现中最复杂的代码仅限于 put() （和删除）方法。二叉查找树中的查找最大和最小键、select()、rank()、floor()、ceiling()和范围查找方法不做任何变动即可继续使用，因为红黑树也是二叉查找树而这些操作也不会涉及到结点的颜色。
