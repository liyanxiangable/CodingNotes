# 虚拟机类加载机制

## 概述

与那些在编译时需要进行连接工作的语言不同，在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为 Java 应用程序提供高度的灵活性，Java 里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。



## 类加载的时机

类从被加载至虚拟机中开始，到卸载出内存为止，它的整个生命周期包括：

1. 加载 Loading
2. 验证 Vertification
3. 准备 Preparation
4. 解析 Resolution
5. 初始化 Initialization
6. 使用 Using
7. 卸载 Unloading

其中验证、准备、解析 3 个部分统称为连接（Linking）。

![](https://i.imgur.com/nWZMBrx.jpg)

加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班的开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定（也称动态绑定或晚期绑定）。

虚拟机规范严格规定了**有且只有** 5 种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：

1. 遇到 new、getstatic、putstatic、invokestatic 这 4 条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。这 4 条指令对应最常见的 Java 代码场景是：使用 new 关键字实例化对象；读取或设置一个类的静态字段（被 final 修饰并且已经在编译期就把结果放入常量池的静态字段除外）的时候；调用一个类的静态方法的时候。
2. 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
3. 当初始化一个类的时候，如果发现其父类还没有被初始化，则需要先初始化其父类。
4. 当虚拟机启动的时候，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。
5. 使用动态语言支持时的某些情况。

以上这 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方法都不会触发类的初始化，称为被动引用。被动引用的典型场景如下：

1. 子类调用父类的静态字段，此时父类被初始化，子类不会被初始化。对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。
2. 创建一个对象（例如 com.liyanxiang.Gakki）数组。这个操作并不会触发 com.liyanxiang.Gakki 这个类的初始化阶段，但是会触发另一个名为“[Lcom.liyanxiang.Gakki”的类的初始化阶段。这个类是有虚拟机自动生成的，直接继承于 java.lang.Object 的子类，创建动作有字节码指令 newarray 触发。
3. 类中的静态编译期常量的使用并不会触发此类的初始化。常量在编译阶段就会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。即通过编译阶段的常量传播优化，已经将常量的值储存到了调用类的常量池中，以后调用类对常量的引用实际上转化为调用类对自身常量池的引用了。

接口的加载与类的加载稍微有一些不同，在于上述 5 条主动加载的第三条：当一个类在初始化的时候，要求父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候才会初始化。



## 类加载的过程

### 加载

“加载”时“类加载”（Class Loading）过程的一个阶段，在加载阶段，虚拟机需要完成以下三件事情：

1. 通过一个类的全限定名来获取定义此类的二进制字节流（可以来源于压缩包、网络、运算时生成、其他文件生成、数据库中读取）
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式储存在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义。然后在内存中实例化一个 java.lang.Class 类的对象（并没有明确规定实在 Java 堆中，对于 HotSpot 虚拟机而言，Class 对象比较特殊，它虽然是对象，但是存放在方法区里面），这个对象将作为程序访问方法区中的这些类型数据的外部接口。

加载阶段与连接阶段的部分内容时交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但是这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。

### 验证

验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求。

Java 语言本身是一个相对安全的语言，但是 Class 文件不一定是由 Java 源码编译出来的，可以使用任何途径产生。在字节码语言层面上，Java 代码无法做到的事情是可以实现的，至少予语义是可以表达出来的。虚拟机如果不检查输入的字节流，对其完全信息的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。

### 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。其中由两点说明：

1. 准备阶段进行内存分配的仅包括类变量（即 static 修饰的变量），而不包括实例变量，实力变量将会在对象实例化时随着对象一起分配在 Java 堆中。
2. 准备阶段所说的初始值“通常情况”下时数据类型的零值，因为这时候尚未开始执行任何 Java 方法，而把 一个静态变量赋值的过程是 putstatic 指令，是在程序被编译后，存放于类构造器 \<climit\>() 方法之中，所以把类变量赋值动作将在初始化阶段才会执行。那么与“通常情况”相对的“特殊情况”，即是类字段的字段属性表中存在 ConstantValue 属性的情况。当一个类变量被定义为常量的时候，javac 编译时会为变量生成 ConstantValue 属性。此时在准备阶段会将类变量初始化为 ConstantValue 属性所指定的值。

### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用在 Class 文件中以 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等类型的常量出现。

### 初始化

类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参数外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码（字节码）。

在准备阶段，变量已经赋过依次系统要求的初始值，而在初始化阶段，则根据程序员通过程序指定的主观计划去初始化变量和其他资源，即初始化阶段是执行类构造器\<clinit\>() 方法的过程。

- \<clinit\>() 方法是由编译器自动收集类中的所有**类变量**的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译期收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量可以在前面的静态语句块中赋值，但是不能访问。
- \<clinit\>() 方法与类的构造函数不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的 \<clinit\>() 方法执行之前，父类的 \<clinit\>() 方法已经执行完毕。
- 由于父类的 \<clinit\>() 方法执行，也就意味着父类总定义的静态与语句块要优先于子类中的静态语句块变量赋值操作。
- \<clinit\>() 方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 \<clinit\>() 方法。
- 接口中不能有使用静态语句块，但仍然有变量初始化的的复制操作，因此接口与类一样都会发生 \<clinit\>() 方法。但接口不同的是，执行接口的 \<clinit\>() 方法不需要先执行父接口的 \<clinit\>() 方法。只有当父接口中定义的变量使用时，父接口才会实例化。另外接口的实现类在初始化时也不会执行接口的 \<clinit\>() 方法。
- 虚拟机会保证一个类的 \<clinit\>() 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类地 \<clinit\>() 方法，其他线程都需要阻塞等待。



## 类加载器

类加载阶段中的“通过一个类地全限定名来获取此类地二进制字节流”这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的代码模块称为“类加载器”。

### 类与类加载器

类加载器虽然只用于实现类的加载操作，但他在 Java 程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类命名空间。通俗地讲，比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义。

### 双亲委派模型

从 Java 虚拟机的角度来讲，只存在两种不同的类加载器：

1. 一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用 C++ 语言实现，是虚拟机自身的一部分
2. 另一种就是所有其他的类加载器，这些类加载器都是由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader

从 Java 开发人员的角度来看，类加载器还可以划分得等细致一些：

1. 启动类加载器（Bootstrap ClassLoader）：这个类加载器负责将存放在 \<JAVA_HOME\>\lib 目录中的，或者是被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。
2. 扩展类加载器（Extension ClassLoader）：负责加载 \<JAVA_HOME\>\lib\ext 目录中的，或者被 java.ext.dirs 系统变量所限定的路径中通过的所有类库，开发者可以直接使用扩展类加载器。
3. 应用程序类加载器（Application ClassLoader）：这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以一般也称它为系统类加载器，它负责加载用户类路径（ClassPath）上所指定的类库。

![](https://i.imgur.com/IDn7x6M.jpg)

上图展示的类加载器之间的层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里的类加载器之间的父子关系一般不以继承关系来实现，而是都使用组合关系来复用父加载器的代码。

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动来加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。

双亲委派模型对于保证 Java 程序的稳定运作很重要，但它的实现却很简单：先检查是否已经被加载过，若没有加载则调用父加载器的 loadClass() 方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出 ClassNotFoundException 异常后，再调用自己的 findClass() 方法进行加载。


