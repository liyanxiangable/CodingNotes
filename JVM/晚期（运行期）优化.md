# 晚期（运行期）优化



## 概述

在部分的商用虚拟机中，Java 程序最初使用过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”（Hot Spot Code）。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler，简称 JIT 编译器）。



## HotSpot 虚拟机内的即时编译器

解释器与编译器两者各有优势：当程序需要迅速自动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。当程序运行环境中内存资源限制较大时，可以使用解释执行节约内存，反之可以使用编译执行来提升效率。



## 编译优化技术

由于虚拟机的优化措施都集中在了即时编译器上，所以即时编译器产生的本地代码会比 Javac 生成的字节码更加优秀。

代码优化变换是建立在代码的某种中间表示或机器码之上，绝不是建立在 Java 源码之上的。常用的优化方式如下：

1. 方法内联（Method Inlining），方法内联的重要性要高于其他优化措施，它的主要目的有两个，一是去除方法调用的成本（如建立栈帧等），二是为其他优化建立良好的基础，方法内联膨胀之后可以便于在更大范围上采取后续的优化子段，从而获取更好的优化效果。因此，各种编译器一本都会把内联优化放在优化序列的最靠前位置。
2. 冗余访问消除（Redundant Loads Elimination），如果有多次访问同一个不变的局部变量，那么可以把访问成员变量看作是一个表达式，把这项优化看成是公共子表达式消除（Common Subexpression Elimination）。
3. 复写传播（Copy Propagation），如果在程序的逻辑中有额外的变量，它与之前的变量是完全相等的，因此可以使用一个变量来代替另一个变量。
4. 无用代码删除（Dead Code Elimination），无用代码可能是永远不会被执行的代码，也可能是完全没有意义的代码。
5. 公共子表达式消除。
6. 数组边界检查消除。
7. 逃逸分析。

