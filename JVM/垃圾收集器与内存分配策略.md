# 垃圾收集器与内存分配策略



## 概述

之前讲到，Java 内存运行时区域分为几个部分，其中程序计数器、虚拟机栈、本地方法栈 3 个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊的执行着入栈与出栈的操作，每一个栈帧中分配多少内存基本上是在类结构确定下来的时候就已知的。因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多地考虑回收地问题，因为方法结束或者线程结束时，内存自然就跟着回收了。而 Java 堆与方法区则不一样，一个接口的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期时才能知道会创建哪些对象，这些内存的分配与回收都是动态的，垃圾收集器关注的是这一部分内存。

## 对象已经死亡吗？

垃圾收集器在对堆进行回收之前，首先要做的就是判断对象是否已经死亡。

### 引用计数法

引用计数法即给对象中添加一个引用计数器，每当有一个地方引用它的时候，计数器值就加 1；当引用失败时，计数器就减 1；任何时刻计数器为 0 的对象就是不可能再被使用的。但是主流的 Java 虚拟机并没有使用引用计数法管理内存，其中最主要的原因在于他很难解决对象相互之间循环引用的问题。

### 可达性分析算法

主流的程序语言的主流实现是通过可达性分析（Reachability Analysis）来判定对象是否存活的。这个算法的基本思想就是通过一系列称为“GC Roots”的对象作为起始点，从这些结点开始向下搜索，搜索所走过的路径称为引用链（References Chain），当一个对象到 GC Roots 没有任何引用链相连（即图论中的不可达）时，则证明此对象时不可用的。

在 Java 语言中，可作为 GC Roots 的对象包括以下几种：

1. 虚拟机栈（栈帧中的本地变量表）中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中 JNI 引用的对象

### 再谈引用

一个对象在除了被引用与没有被引用之外，还有一种游离的状态。我们希望能够描述这样一种对象：当内存空间还足够的时候，则能保留在内存之中；如果内存空间在上进行垃圾收集后还是非常紧张，则可以抛弃这些对象。在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为强度依次减弱的四种引用：

1. 强引用。是指在程序代码中普遍存在的，显式的引用关系。只要强引用存在，垃圾收集器就永远不会回收掉被引用的对象。
2. 软引用。是指一些还有用但是并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这个回收还没有足够的内存，才会抛出内存溢出异常。
3. 弱引用。是用来描述一类比软引用的强度还弱一些的非必需对象。被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
4. 虚引用。是最弱的一种引用关系。一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实例。

### 生存还是死亡

即使是在可达性分析算法中不可达的对象，也并非是“非死不可的”，这时候他们暂时处于“缓刑阶段”。要真正宣告一个对象死亡，至少要经历两个过程：

1. 如果对象在经过可达性分析后发现没有与 GC Roots 相连接的引用链，那么它将会被第一次标记并进行筛选，筛选的条件是此对象是否有必要进行 finalize 方法。当对象没有覆盖 finalize 方法或者是 finalize 方法已经被调用过，虚拟机将这两种情况视为“没有必要执行”。
2. 如果这个对象被判定为有必要执行 finalize 方法，那么这个对象将会放置在一个叫做 F-Queue 的队列之中，并在稍后有一个虚拟机自动建立的、低优先级的 Finalizer 线程去执行。虚拟机会触发 finalize 方法，但是不承诺会等待方法运行结束。finalize 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize 中成功拯救自己，只要重新与引用链上的任何一个对象建立联系即可；如果这个对象在此时还没有逃脱，那么它就真的被回收了。任何一个对象的 finalize 方法只会被系统自动调用一次。



## 垃圾收集算法

当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。



## 内存分配与回收策略

Java 技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。

对象的内存分配，往大方向讲，就是在堆上分配，对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲，将按线程优先在 TLAB 上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数设置。

### 对象优先在 Eden 分配

大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。

### 大对象直接进入老年代

所谓的大对象是指，需要大量连续内存空间的 Java 对象，最典型的大对象就是那种很长的字符串及数组，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获得足够的连续空间来“安置”他们。

### 长期存活的对象将进入老年代

为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能够被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且对象的年龄设为 1。对象在 Survivor 区中每“熬过”一次 Minor GC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就将会晋升到老年代中。

