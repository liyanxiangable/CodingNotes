# 线程与并发基础



## 线程安全性

当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。Java 中的主要同步机制时关键字 synchronized，它提供了一种独占的加锁方式，但“同步”这个术语还包括 volatile 类型的变量，显式锁（Explicit Lock）以及原子变量。

当多个线程访问某个类的时候，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并发在主调代码中不需要任何额外的同步或协调，这个类都能表现出正确的行为，那么就成这个类是线程安全的。

无状态对象一定是线程安全的。

在并发编程中，由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，叫做竞态条件（Race Condition）。当某个计算的正确性取决于多个线程的交替执行时序的时候，那么就会发生竞态条件。

要避免竞态条件问题，就必须在某个线程修改该变量的时候，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或之后读取和修改状态，而不是在修改的过程之中。

假定有两个操作 A 与 B，如果从执行 A 的线程来看，当另一个线程在执行 B 的时候，要么将 B 执行完，要么完全不执行 B，那么 A 和 B 对彼此来说是原子的，原子操作是指，对于访问同一个状态的所有操作来说，这个操作是一个以原子方式执行的操作（不可再分）。

要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。

Java 提供而另一种内置的锁机制来支持原子性：同步代码块（Synchronized Block）。同步代码块包括两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。

每个 Java 对象都可以同做一个实现同步的锁，这些锁被称为内置锁（Intrinsic Lock）或监视器锁（Monitor Lock）。线程在进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁，而无论是通过正常的控制路径退出，还是通过代码块中抛出异常退出。获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。

Java 的内置锁相当于一种互斥体（或互斥锁），这意味着最多只有一个线程能持有这种锁。当线程 A 尝试获取一个由线程 B 持有的锁时，线程 A 必须等待或者阻塞，直到线程 B 释放这个锁。如果 B 永远不释放锁，那么 A 也将永远等待下去。

由于每次只能有一个线程执行内置锁保护的代码块，因此由这个锁保护的同步代码块会以原子方式执行，多个线程在执行该代码块的时候也不会相互干扰。

当某个线程请求一个由其他线程持有的锁的时候，发出请求的线程就会阻塞。然而由于内置锁时可重入的，因此如果某个线程视图获得一个已经由它自己持有的锁，那么这个请求就会成功。重入的一种实现方法是为每个锁关联一个获取计数值和一个所有者线程。当计数值为 0 时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM 将记下锁的持有者，并将计数值递增；而当线程退出同步代码块时，计数器会相应地递减，计数值为 0 时，这个锁将被释放。



# 对象的共享

## 可见性

只要在某个线程中无法检测到重排序情况，那么就无法确保线程中的操作将按照程序中指定的顺序来执行。

在没有同步的情况下，编译器、处理器以及运行时等可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。只要有数据在多个线程之间共享，就应当使用正确的同步。

有一种在缺乏同步的程序中可能产生错误结果的一种情况：失效数据。当线程查看某个变量的时候，可能会得到一个已经失效的值。除非在每次访问变量时都是用同步，否则很可能获得该变量的一个失效值。Java 内存模型要求，变量的读取操作和写入操作都必须是原子操作，但是对于非 volatile 类型的 long 与 double 变量，JVM 允许将 64 位的读写操作分解为两个 32 位的操作。当读取一个非 volatile 类型的 long 变量时，如果对该变量的读写操作在不同的线程中执行，那么很可能会读取到某个值的高 32 位和另一个值的低 32 位。因此即使不考虑失效数据问题，在多线程程序中使用共享且可变的 long 和 double 等类型的变量也是不安全的，除非是用关键字 volatile 来声明他们，或者使用锁来保护起来。

内置锁可以用于确保某个线程以一种可预测的方式来查看另一个线程的执行结果。在访问某个共享且可变的变量时要求所有线程在同一个锁上同步，就是为了确保某个线程写入该变量的值对于其他线程来说都是可见的。否则，如果一个线程在未持有正确锁的情况下读取某个变量，那么读到的可能是一个失效值。

加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。

Java 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。当把变量声明位 volatile 类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile 变量不会被还存在寄存去或者对其他处理器不可见的地方，因此在读取 volatile 来行的变量时总会返回最新写入的值。

在访问 volatile 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此 volatile 变量使一种比 synchronized 关键字更轻量级的同步机制。加锁机制既可以确保可见性又可以确保原子性，而 volatile 变量只能确保可见性。

## 发布与逸出

“发布（Publish）”一个对象是指，使对象能够在当前作用域之外的代码中使用。当某个不应该发布的时候发布，这种情况称为逸出（Escape）。

## 线程封闭

当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据，如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭（Thread Confinement），它是实现线程安全性的最简单的方式之一。

线程封闭技术的常见应用是 JDBC（Java Database Connectivity）的 Connection 对象。线程从连接池中获得一个 Connection 对象，并用该对象来处理请求，在 Connection 对象返回之前，连接池不会再分配给其他线程。因此这种连接管理模式再处理请求时隐含地将 Connection 对象封闭在线程中。

### Ad-hoc 线程封闭

Ad-hoc 线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。由于 Ad-hoc 线程封闭技术的脆弱性，因此在程序中尽量少用它。

### 栈封闭

栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中。它们位于执行线程的栈中，其他线程无法访问这个栈。

### ThreadLocal 类

维持线程封闭性的一种更为规范的方法是使用 ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。TheadLocal 提供了 get 与 set 等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此 get 总是返回由当前执行线程在调用 set 时设置的最新值。ThreadLocal 对象通常用于防止对可变的单例变量（Singleton）或全局变量进行共享。

当某个线程初次调用 ThreadLocal.get 方法时，就会调用 initValue 来获取初始值。



## 不变性

满足同步需求的另一种方法时使用不可变对象（Immutable Object）。如果对象的状态不会改变，那么也就不存在同步的问题与复杂性。如果某个对象在被创建后其状态就不能被修改，那么这个对象就称为不可变对象，不可变对象一定是线程安全的。

不可变性并不等于将对象中所有的域都声明为 final 类型，因为在 final 类型的域中可以保存对变量对象的引用。

对象是不可变的需要满足以下的条件：

1. 对象创建以后其状态就不能修改
2. 对象的所有域都是 final 类型
3. 对象是正确创建的（在对象的引用期间，this 引用没有逸出）

在 Java 内存模型中，final 域还有着特殊的语义。final 域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无需同步。



# 并发容器



Java 5.0 提供了多种并发容器来改进同步容器的性能。同步容器将所有对容器状态的访问都进行串行化，以实现它们的线程安全性，这种方法的代价是严重降低并发性，当多个线程竞争容器的锁时，吞吐量将严重降低。Java 5.0 中增加了 ConcurrentHashMap，用来替代同步且基于散列的 Map，以及 CopyOnWriteArrayList 等多种容器。

## ConcurrentHashMap

传统的同步容器类在执行每个操作期间都持有一个锁。而与 HashMap 一样，ConcurrentHashMap 也是一个基于散列的 Map，但是它使用了一种完全不同的加锁策略来提供更高的并发性与伸缩性。ConcurrentHashMap 并不是将每个方法都在同一个锁上同步并使得每次只能有一个线程访问容器，而是使用一种粒度更细的方式加锁机制来实现更大程度的共享，这种机制称为分段加锁（Lock Striping）。在这种机制中，任意数量的读取线程可以并发地访问 Map，执行读取操作地线程和执行写入操作地线程可以并发地访问 Map，并且一定数量的写入线程可以并发地修改 Map，所以，使用 ConcurrentHashMap 会在并发访问环境下将实现更高地吞吐量，而在单线程环境中只损失非常小地性能。

## BlockingQueue 与生产者—消费者模式

阻塞队列提供了可阻塞的 put 和 take 方法，以及支持定时的 offer 和 poll 方法，如果队列已经满了，那么 put 方法将阻塞直到有空间可用；如果队列为空，那么 take 方法将会阻塞直到有元素可用。队列可以时有界的也可以时无界的，其中无界队列永远不会充满，因此无界队列的 put 方法也永远不会阻塞。

阻塞队列支持**生产者—消费者**这种设计模式。该模式将“找出需要完成的工作”与“执行工作”这两个过程分离开来，并把工作项放入一个“待完成”列表中以便在随后处理，而不是找出后立即处理。

阻塞队列提供一个 offer 方法，如果数据项不能被添加到队列之中，那么将返回一个失败状态。这样就能够创建更过灵活的策略来处理负荷过载的情况。

在类库中包含了 BlockingQueue 的多种实现，其中，LinkedBlockingQueue 和 ArrayBlockingQueue 是 FIFO 队列，两者分别于 LinkedList 与 ArrayList 类似，但比同步 List 拥有更好的并发性能。PriorityBlockingQueue 是一个按优先级排列的队列，当希望按照某种顺序而不是 FIFO 来处理元素时可以使用这个队列。

## 阻塞方法与中断方法

线程可以能会阻塞或者暂停执行，当线程阻塞时，它通常被挂起，并处于某种阻塞状态（BLOCKED, WAITING, TIMED_WAITING）。阻塞操作与执行时间很长的普通操作的不同之处在于，被阻塞的线程必须等待某个不受它控制的事件的发生后才能继续执行，当某个外部事件发生时，线程被置回 RUNNABLE 状态，并可以再次被调度执行。

Thread 提供了 interrupt 方法，用于中断线程或者查询线程是否已经被中断。每个线程都有一个布尔类型的属性，来表示线程的中断状态。中断是一种协作机制，一个线程不能强制其他线程停止生在执行的操作而去执行其他的操作。

当代码中调用了一个将抛出 InterruptException 异常的方法时，自己的方法也就变成了一个阻塞方法，并且必须要处理对中断的响应。

























## 参考与感谢

1. [彻底理解ThreadLocal](https://www.cnblogs.com/xzwblog/p/7227509.html)