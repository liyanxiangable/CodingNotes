# 十六章 数组



## 数组为何特殊

数组与其他种类的容器之间的区别有三个方面：效率、类型以及保存基本类型的能力。在Java中，数组是一种效率最高的存储和随机访问对象引用序列的方式。数组就是一个简单的线性序列，这使得元素访问非常快速。但是为这种速度所付出的代价就是数组对象的大小被固定。

在泛型之前，其他的容器类在处理对象时，都将它们看作没有任何具体类型。也就是说，他们将这些对象都当作java中所有类的根类Object来处理。数组之所以优于反省之前的容器，就是因为你可以创建一个数组去持有某种具体类型。这意味着你可以通过编译器的检查，来防止插入错误类型或是抽取不当类型。

数组可以持有基本类型，而泛型之前的容器不可以。但是有了泛型，容器就可以指定并检查他们所持有对象的类型，并且有了自动包装机制，容器看起来也能持有基本类型元素。

随着自动包装机制的出现，容器已经可以与数组几乎一样方便的使用于基本类型中了。数组仅有的有点就是效率了。



## 数组是第一级对象

无论使用哪种类型的数组，数组标识符其实只是一个引用，指向在堆中创建的一个真实对象，这个（数组）对象用以保存指向其他对象的引用。可以作为数组初始化语法的一部分隐式地创建此对象，或者用new表达式显式地创建。只读成员length是数组对象的一部分，表示此数组对象可以存储多少元素。“[]”语法是访问数组对象的唯一方式。

对象数组和基本类型数组在使用上几乎是想用的，唯一的区别在于对象数组保存的是引用，基本类型数组直接保存基本类型的值。

对于length属性，他只表示数组能够容纳多少个元素，但是无法直到在此数组中确切有多少个元素。即length是指数组的大小，而不是实际保存的元素个数。

新生成一个数组对象时，其中所有的引用被初始化为null，所以只需要检验其中的引用是否为null，即可知道某个位置是否存有对象。同样，各种基本类型也都置零，因为基本类型的数组对象也是存在于堆空间中的。



## 返回一个数组

在Java中，编写一个方法想要返回一组值，不必像C/C++中考虑那么多，只需要直接的返回一个数组。只要这个数据还需要使用，他就会一直存在，当你使用完之后，垃圾回收器会清理掉它。返回一个数组于放回任何其他对象（实质上时返回引用）没有什么区别，数组时在哪个函数中创建并不重要。当使用完毕之后，垃圾回收器会负责清理数组；而只要还需要他，此数组就会一直存在。



## 多维数组

创建多维数组很方便，对于基本类型的所谓数组，可以通过使用花括号将每个向量分隔开。数组中构成矩阵的每个向量都可以具有任意的长度（这被称为粗糙数组）。多维数组的输出可以使用Arrays.deepToString()方法。



## Arrays 实用功能

在java.util类库中可以找到Arrays类，他有一套用于数组的static实用方法，其中有六个基本方法：

1. equals()                用于比较两个数组是否相等（deepEquals用于多维数组）
2. fille()                     可以填充整个数组或者数组的一部分，部分填充区间为左闭右开
3. sort()                     对数组排序
4. binarySearch()    对已经有序的数组进行二分查找
5. toString()             产生数组的String表示
6. hashCode()          产生数组的散列码

另外，Arrays.asList()方法接受任意的序列或者数组作为其参数，并将他们转为List容器。

Java标准类库提供static方法System.arraycopy()，用它来复制数组比使用for循环复制要快很多。arraycopy()需要的参数有：源数组、表示从源数组什么位置开始复制的偏移量、目标数组、表示从目标数组的什么位置开始复制的偏移量、以及需要复制的元素个数。对数组的任何越界操作都会导致异常。基本类型数组于对象（引用）数组都可以进行复制，但是如果复制对象数组，那么只是复制了对象的引用——而不是对象本身的拷贝。arraycopy()不会执行自动包装和自动拆包，两个数组必须具有相同的确切数据类型。

Arrays类提供了重载后的equals()方法，用来比较整个数组。数组相等的条件为：元素的个数必须相等，并且对应位置的元素也相等（这可以通过对每一个元素使用equals()作比较来判断）。

程序设计的基本目标是“将保持不变的事物与会发生改变的事物相分离”，对于数组元素的比较而言，不变的是通用的排序算法，变化的是各种对象相互比较的方式。因此不是将进行比较的代码编写成不同的子程序，而是使用策略设计模式。通过使用策略，可以将“会发生变化的代码”封装在单独的类（策略对象）中，编程人员可以把策略对象传递给相同的代码，这些代码将使用策略来完成其算法。通过这种方式，编程人员能够用不同的对象来表示不同的比较方式，然后将它们传递给相同的排序代码。

Java有两种方式来提供比较功能。第一种是实现java.lang.Comparable接口，这种方式使实现类具有天生的比较能力。只需要实现compareTo()方法，这个方法接收另一个同类型对象为参数，如果当前对象小于参数对象，那么则返回负值，相等返回零，大于返回正值。这种返回值使得排序结果为升序。

但是假如有人给出的类没有实现comparable接口，或者是给出的类虽然实现了comparable接口，但是其中的compareTo方法实现不是想要的排序方式，那么可以创建一个实现了Comparator接口的类，来对上文中的类进行比较以排序。新创建的类有两个方法：compare()和equals()。由于Object根类带有equals方法，所以一般情况下实现compare()方法就足够使用了。

使用内置的排序方法可以对任意的基本类型数组排序。只要对象数组中的元素实现了Comparable接口或者使具有相关的Comparator，也可以对任意对象数组进行排序。String排序算法依据词典顺序排序。如果向忽略大小写字母将所有单词都放在一起排序，那么就可以在sort方法的第二个参数中传递String.CASE_INSENSITIVE_ORDER。java内置的sort方法对基本类型排序使用快速排序，对对象进行排序使用稳定归并排序。

排序之后可以使用binarySearch()方法来进行查找元素，如果找到目标，那么返回值为一个非负数；如果没有找到目标，那么返回负数，这个负值可以表示保持数组排序状态的前提下，这个目标元素应该插入的位置。这个负值的计算方法为：

```java
return = -(插入点) - 1	// 所以插入点索引 = -1 - return
```

如果数组包含重复的元素，则无法保证找到的使这些副本中的哪一个。

如果使用comparator排序了某个对象数组（基本类型数组无法使用comparator进行排序），那么在使用binarySearch()时必须提供同样的comparator。



这一篇一行代码也没有啊~

